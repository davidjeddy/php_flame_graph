<?php
# Copyright 2018 Miriam Lauter (lauter.miriam@gmail.com).  All rights reserved.
#
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License
#  as published by the Free Software Foundation; either version 2
#  of the License, or (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software Foundation,
#  Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
#  (http://www.gnu.org/copyleft/gpl.html)
#
# 13-04-2018   Miriam Lauter    Created this.
# 05-07-2023   David J Eddy     Updated to work with PHP >= 8.x < 9 and xDebug >= 3.x, < 4

## Constants

const SCALE_FACTOR = 1000000;

## Functions

function usage($exit = 0) {
    echo <<<EOT
    stackcollapse-xdebug.php  collapse php function traces into single lines.

    Parses php samples generated by xdebug with xdebug.trace_format = 1
    and outputs stacks as single lines, with methods separated by semicolons,
    and then a space and an occurrence count. For use with flamegraph.pl.
    See https://github.com/brendangregg/FlameGraph.

    USAGE: ./stackcollapse-xdebug.php [OPTIONS] infile > outfile
        -c --counts  Invocation counts only. Simply count stacks in the trace and sum duplicates, don't weight by duration.
        -h --help    Show this message

    Example input:
    -----
    For more info on xdebug and generating traces see
    https://xdebug.org/docs/execution_trace.

    Version: 2.0.0RC4-dev
    TRACE START [2007-05-06 18:29:01]
    1    0    0    0.010870    114112    {main}    1    index.php    0
    2    1    0    0.032009    114272    str_split    0    index.php    8
    2    1    1    0.032073    116632
    2    2    0    0.033505    117424    ret_ord    1    index.php    10
    3    3    0    0.033531    117584    ord    0    index.php    5
    3    3    1    0.033551    117584
    TRACE END   [2007-05-06 18:29:01]
    -----

    Example output:
    -----
    {main} 23381
    {main};str_split 64
    {main};ret_ord 215
    {main};ret_ord;ord 106
    -----

    Example output using `-c`||`--count`
    -----
    {main};str_split 1
    {main};ret_ord;ord 6
    -----
    EOT;

    exit($exit);
}

function collapseStack(array $stack, string $func_name_key): string {
    return implode(';', array_column($stack, $func_name_key));
}

function addCurrentStackToStacks(array $stack, float $dur, array &$stacks) {
    $collapsed      = implode(';', $stack);
    $duration       = SCALE_FACTOR * $dur;

    if (array_key_exists($collapsed, $stacks)) {
        $stacks[$collapsed] += $duration;
    } else {
        $stacks[$collapsed] = $duration;
    }
}

function isEOTrace(string $line) {
    return preg_match("/^(\\s+|TRACE END)/", $line);
}

## Logic

$args = getopt("cht", ["count", "help", "time"]);

if (isset($args['h']) || isset($args['help']) || $argv[0] === null) {
    usage();
}

$do_time = (!isset($args['c']) || !isset($args['count']));
$filename = $argv[1]; # set argument 0 to $filename

// var_dump($do_time);
// var_dump($filename);

// First make sure our file is consistently formatted with only one \t delimiting each field
$outPut = [];
$exitCode = null;
exec("sed 's/\s\+/\s/g' " . escapeshellarg($filename), $outPut, $exitCode);
if ($exitCode !== 0) {
    echo "ERROR: \$exitCode empty after parsing trace file, exiting.\n";
    exit(1);
}

// var_dump($filename);
// var_dump($outPut);
// var_dump($exitCode);

$handle = fopen($filename, 'r');
if ($handle === false) {
    echo "Unable to open $filename, exiting.\n";
    exit(1);
}

// var_dump($filename);
// var_dump($handle);

// Loop till we find TRACE START
while ($line = fgets($handle)) {
    if (strpos($line, "TRACE START") === 0) {
        break;
    }
}

// var_dump($line);

$current_stack = [];
$prev_start_time = 0;
$stacks = [];
$was_exit = false;

// var_dump($stacks);
// var_dump($current_stack);
// var_dump($was_exit);
// var_dump($prev_start_time);

if ($do_time) {
    // Weight counts by duration
    // Xdebug trace time indices have 6 significant figures of precision
    // We have a perfect trace, but let's instead pretend that
    // this was collected by sampling at 10^6 Hz
    // then each millionth of a second this stack took to execute is 1 count
    while ($line = fgets($handle)) {
        // var_dump($line);

        if (isEOTrace($line)) { break; }

        $parts = preg_split('/\s+/', $line);
        list($level, $fn_no, $is_exit, $time) = $parts;

        // var_dump($level);
        // var_dump($fn_no);
        // var_dump($is_exit);
        // var_dump($time);

        if ($is_exit) {
            if (empty($current_stack)) {
                echo "[WARNING] Found function exit without corresponding entrance. Discarding line. Check your input.\n";
                continue;
            }

            addCurrentStackToStacks($current_stack, $time - $prev_start_time, $stacks);
            array_pop($current_stack);
        } else {
            $func_name = $parts[5];

            if (!empty($current_stack)) {
                addCurrentStackToStacks($current_stack, $time - $prev_start_time, $stacks);
            }

            $current_stack[] = $func_name;
            // var_dump($func_name);
            // var_dump($current_stack);
        }

        $prev_start_time = $time;

        // var_dump($time);
        // var_dump($prev_start_time);
    }
} else {
    // Counts only
    while ($line = fgets($handle)) {
        if (isEOTrace($line)) { break; }

        $parts = preg_split('/\s+/', $line);
        list($level, $fn_no, $is_exit, $time) = $parts;

        if ($is_exit === "1") {
            if (!$was_exit) {
                $collapsed = implode(";", $current_stack);
                if (array_key_exists($collapsed, $stacks)) {
                    $stacks[$collapsed]++;
                } else {
                    $stacks[$collapsed] = 1;
                }
            }

            array_pop($current_stack);
            $was_exit = true;
        } else {
            $func_name = $parts[5];
            $current_stack[] = $func_name;
            $was_exit = false;
        }
    }
}

foreach ($stacks as $stack => $count) {
    echo "$stack $count\n";
}
